/*
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@looker.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.looker.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * DBConnectionOverride
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-02-15T12:39:13.185-08:00[America/Los_Angeles]")public class DBConnectionOverride {

  @SerializedName("context")
  private String context = null;

  @SerializedName("host")
  private String host = null;

  @SerializedName("port")
  private String port = null;

  @SerializedName("username")
  private String username = null;

  @SerializedName("password")
  private String password = null;

  @SerializedName("has_password")
  private Boolean hasPassword = null;

  @SerializedName("certificate")
  private String certificate = null;

  @SerializedName("file_type")
  private String fileType = null;

  @SerializedName("database")
  private String database = null;

  @SerializedName("schema")
  private String schema = null;

  @SerializedName("jdbc_additional_params")
  private String jdbcAdditionalParams = null;

  @SerializedName("after_connect_statements")
  private String afterConnectStatements = null;

  @SerializedName("can")
  private Map<String, Boolean> can = null;
  public DBConnectionOverride context(String context) {
    this.context = context;
    return this;
  }

  

  /**
  * Context in which to override (&#x60;pdt&#x60; is the only allowed value)
  * @return context
  **/
  @Schema(description = "Context in which to override (`pdt` is the only allowed value)")
  public String getContext() {
    return context;
  }
  public void setContext(String context) {
    this.context = context;
  }
  public DBConnectionOverride host(String host) {
    this.host = host;
    return this;
  }

  

  /**
  * Host name/address of server
  * @return host
  **/
  @Schema(description = "Host name/address of server")
  public String getHost() {
    return host;
  }
  public void setHost(String host) {
    this.host = host;
  }
  public DBConnectionOverride port(String port) {
    this.port = port;
    return this;
  }

  

  /**
  * Port number on server
  * @return port
  **/
  @Schema(description = "Port number on server")
  public String getPort() {
    return port;
  }
  public void setPort(String port) {
    this.port = port;
  }
  public DBConnectionOverride username(String username) {
    this.username = username;
    return this;
  }

  

  /**
  * Username for server authentication
  * @return username
  **/
  @Schema(description = "Username for server authentication")
  public String getUsername() {
    return username;
  }
  public void setUsername(String username) {
    this.username = username;
  }
  public DBConnectionOverride password(String password) {
    this.password = password;
    return this;
  }

  

  /**
  * (Write-Only) Password for server authentication
  * @return password
  **/
  @Schema(description = "(Write-Only) Password for server authentication")
  public String getPassword() {
    return password;
  }
  public void setPassword(String password) {
    this.password = password;
  }
  /**
  * Whether or not the password is overridden in this context
  * @return hasPassword
  **/
  @Schema(description = "Whether or not the password is overridden in this context")
  public Boolean isHasPassword() {
    return hasPassword;
  }
  public DBConnectionOverride certificate(String certificate) {
    this.certificate = certificate;
    return this;
  }

  

  /**
  * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
  * @return certificate
  **/
  @Schema(description = "(Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).")
  public String getCertificate() {
    return certificate;
  }
  public void setCertificate(String certificate) {
    this.certificate = certificate;
  }
  public DBConnectionOverride fileType(String fileType) {
    this.fileType = fileType;
    return this;
  }

  

  /**
  * (Write-Only) Certificate keyfile type - .json or .p12
  * @return fileType
  **/
  @Schema(description = "(Write-Only) Certificate keyfile type - .json or .p12")
  public String getFileType() {
    return fileType;
  }
  public void setFileType(String fileType) {
    this.fileType = fileType;
  }
  public DBConnectionOverride database(String database) {
    this.database = database;
    return this;
  }

  

  /**
  * Database name
  * @return database
  **/
  @Schema(description = "Database name")
  public String getDatabase() {
    return database;
  }
  public void setDatabase(String database) {
    this.database = database;
  }
  public DBConnectionOverride schema(String schema) {
    this.schema = schema;
    return this;
  }

  

  /**
  * Scheme name
  * @return schema
  **/
  @Schema(description = "Scheme name")
  public String getSchema() {
    return schema;
  }
  public void setSchema(String schema) {
    this.schema = schema;
  }
  public DBConnectionOverride jdbcAdditionalParams(String jdbcAdditionalParams) {
    this.jdbcAdditionalParams = jdbcAdditionalParams;
    return this;
  }

  

  /**
  * Additional params to add to JDBC connection string
  * @return jdbcAdditionalParams
  **/
  @Schema(description = "Additional params to add to JDBC connection string")
  public String getJdbcAdditionalParams() {
    return jdbcAdditionalParams;
  }
  public void setJdbcAdditionalParams(String jdbcAdditionalParams) {
    this.jdbcAdditionalParams = jdbcAdditionalParams;
  }
  public DBConnectionOverride afterConnectStatements(String afterConnectStatements) {
    this.afterConnectStatements = afterConnectStatements;
    return this;
  }

  

  /**
  * SQL statements (semicolon separated) to issue after connecting to the database. Requires &#x60;custom_after_connect_statements&#x60; license feature
  * @return afterConnectStatements
  **/
  @Schema(description = "SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature")
  public String getAfterConnectStatements() {
    return afterConnectStatements;
  }
  public void setAfterConnectStatements(String afterConnectStatements) {
    this.afterConnectStatements = afterConnectStatements;
  }
  /**
  * Operations the current user is able to perform on this object
  * @return can
  **/
  @Schema(description = "Operations the current user is able to perform on this object")
  public Map<String, Boolean> getCan() {
    return can;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DBConnectionOverride dbConnectionOverride = (DBConnectionOverride) o;
    return Objects.equals(this.context, dbConnectionOverride.context) &&
        Objects.equals(this.host, dbConnectionOverride.host) &&
        Objects.equals(this.port, dbConnectionOverride.port) &&
        Objects.equals(this.username, dbConnectionOverride.username) &&
        Objects.equals(this.password, dbConnectionOverride.password) &&
        Objects.equals(this.hasPassword, dbConnectionOverride.hasPassword) &&
        Objects.equals(this.certificate, dbConnectionOverride.certificate) &&
        Objects.equals(this.fileType, dbConnectionOverride.fileType) &&
        Objects.equals(this.database, dbConnectionOverride.database) &&
        Objects.equals(this.schema, dbConnectionOverride.schema) &&
        Objects.equals(this.jdbcAdditionalParams, dbConnectionOverride.jdbcAdditionalParams) &&
        Objects.equals(this.afterConnectStatements, dbConnectionOverride.afterConnectStatements) &&
        Objects.equals(this.can, dbConnectionOverride.can);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(context, host, port, username, password, hasPassword, certificate, fileType, database, schema, jdbcAdditionalParams, afterConnectStatements, can);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DBConnectionOverride {\n");
    
    sb.append("    context: ").append(toIndentedString(context)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    hasPassword: ").append(toIndentedString(hasPassword)).append("\n");
    sb.append("    certificate: ").append(toIndentedString(certificate)).append("\n");
    sb.append("    fileType: ").append(toIndentedString(fileType)).append("\n");
    sb.append("    database: ").append(toIndentedString(database)).append("\n");
    sb.append("    schema: ").append(toIndentedString(schema)).append("\n");
    sb.append("    jdbcAdditionalParams: ").append(toIndentedString(jdbcAdditionalParams)).append("\n");
    sb.append("    afterConnectStatements: ").append(toIndentedString(afterConnectStatements)).append("\n");
    sb.append("    can: ").append(toIndentedString(can)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
