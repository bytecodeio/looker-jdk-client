/*
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@looker.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.looker.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.looker.client.model.Group;
import com.looker.client.model.LDAPGroupRead;
import com.looker.client.model.LDAPGroupWrite;
import com.looker.client.model.LDAPUserAttributeRead;
import com.looker.client.model.LDAPUserAttributeWrite;
import com.looker.client.model.Role;

import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * LDAPConfig
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-02-15T12:39:13.185-08:00[America/Los_Angeles]")public class LDAPConfig {

  @SerializedName("enabled")
  private Boolean enabled = null;

  @SerializedName("connection_host")
  private String connectionHost = null;

  @SerializedName("connection_port")
  private String connectionPort = null;

  @SerializedName("connection_tls")
  private Boolean connectionTls = null;

  @SerializedName("connection_tls_no_verify")
  private Boolean connectionTlsNoVerify = null;

  @SerializedName("auth_username")
  private String authUsername = null;

  @SerializedName("auth_password")
  private String authPassword = null;

  @SerializedName("has_auth_password")
  private Boolean hasAuthPassword = null;

  @SerializedName("user_bind_base_dn")
  private String userBindBaseDn = null;

  @SerializedName("user_id_attribute_names")
  private String userIdAttributeNames = null;

  @SerializedName("user_objectclass")
  private String userObjectclass = null;

  @SerializedName("user_custom_filter")
  private String userCustomFilter = null;

  @SerializedName("user_attribute_map_email")
  private String userAttributeMapEmail = null;

  @SerializedName("user_attribute_map_first_name")
  private String userAttributeMapFirstName = null;

  @SerializedName("user_attribute_map_last_name")
  private String userAttributeMapLastName = null;

  @SerializedName("user_attribute_map_ldap_id")
  private String userAttributeMapLdapId = null;

  @SerializedName("merge_new_users_by_email")
  private Boolean mergeNewUsersByEmail = null;

  @SerializedName("alternate_email_login_allowed")
  private Boolean alternateEmailLoginAllowed = null;

  @SerializedName("modified_at")
  private String modifiedAt = null;

  @SerializedName("modified_by")
  private String modifiedBy = null;

  @SerializedName("default_new_user_groups")
  private List<Group> defaultNewUserGroups = null;

  @SerializedName("default_new_user_roles")
  private List<Role> defaultNewUserRoles = null;

  @SerializedName("default_new_user_role_ids")
  private List<Long> defaultNewUserRoleIds = null;

  @SerializedName("default_new_user_group_ids")
  private List<Long> defaultNewUserGroupIds = null;

  @SerializedName("set_roles_from_groups")
  private Boolean setRolesFromGroups = null;

  @SerializedName("groups")
  private List<LDAPGroupRead> groups = null;

  @SerializedName("groups_with_role_ids")
  private List<LDAPGroupWrite> groupsWithRoleIds = null;

  @SerializedName("auth_requires_role")
  private Boolean authRequiresRole = null;

  @SerializedName("groups_finder_type")
  private String groupsFinderType = null;

  @SerializedName("groups_base_dn")
  private String groupsBaseDn = null;

  @SerializedName("groups_member_attribute")
  private String groupsMemberAttribute = null;

  @SerializedName("groups_user_attribute")
  private String groupsUserAttribute = null;

  @SerializedName("groups_objectclasses")
  private String groupsObjectclasses = null;

  @SerializedName("force_no_page")
  private Boolean forceNoPage = null;

  @SerializedName("test_ldap_user")
  private String testLdapUser = null;

  @SerializedName("test_ldap_password")
  private String testLdapPassword = null;

  @SerializedName("user_attributes")
  private List<LDAPUserAttributeRead> userAttributes = null;

  @SerializedName("user_attributes_with_ids")
  private List<LDAPUserAttributeWrite> userAttributesWithIds = null;

  @SerializedName("url")
  private String url = null;

  @SerializedName("can")
  private Map<String, Boolean> can = null;
  public LDAPConfig enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  

  /**
  * Enable/Disable LDAP authentication for the server
  * @return enabled
  **/
  @Schema(description = "Enable/Disable LDAP authentication for the server")
  public Boolean isEnabled() {
    return enabled;
  }
  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }
  public LDAPConfig connectionHost(String connectionHost) {
    this.connectionHost = connectionHost;
    return this;
  }

  

  /**
  * LDAP server hostname
  * @return connectionHost
  **/
  @Schema(description = "LDAP server hostname")
  public String getConnectionHost() {
    return connectionHost;
  }
  public void setConnectionHost(String connectionHost) {
    this.connectionHost = connectionHost;
  }
  public LDAPConfig connectionPort(String connectionPort) {
    this.connectionPort = connectionPort;
    return this;
  }

  

  /**
  * LDAP host port
  * @return connectionPort
  **/
  @Schema(description = "LDAP host port")
  public String getConnectionPort() {
    return connectionPort;
  }
  public void setConnectionPort(String connectionPort) {
    this.connectionPort = connectionPort;
  }
  public LDAPConfig connectionTls(Boolean connectionTls) {
    this.connectionTls = connectionTls;
    return this;
  }

  

  /**
  * Use Transport Layer Security
  * @return connectionTls
  **/
  @Schema(description = "Use Transport Layer Security")
  public Boolean isConnectionTls() {
    return connectionTls;
  }
  public void setConnectionTls(Boolean connectionTls) {
    this.connectionTls = connectionTls;
  }
  public LDAPConfig connectionTlsNoVerify(Boolean connectionTlsNoVerify) {
    this.connectionTlsNoVerify = connectionTlsNoVerify;
    return this;
  }

  

  /**
  * Do not verify peer when using TLS
  * @return connectionTlsNoVerify
  **/
  @Schema(description = "Do not verify peer when using TLS")
  public Boolean isConnectionTlsNoVerify() {
    return connectionTlsNoVerify;
  }
  public void setConnectionTlsNoVerify(Boolean connectionTlsNoVerify) {
    this.connectionTlsNoVerify = connectionTlsNoVerify;
  }
  public LDAPConfig authUsername(String authUsername) {
    this.authUsername = authUsername;
    return this;
  }

  

  /**
  * Distinguished name of LDAP account used to access the LDAP server
  * @return authUsername
  **/
  @Schema(description = "Distinguished name of LDAP account used to access the LDAP server")
  public String getAuthUsername() {
    return authUsername;
  }
  public void setAuthUsername(String authUsername) {
    this.authUsername = authUsername;
  }
  public LDAPConfig authPassword(String authPassword) {
    this.authPassword = authPassword;
    return this;
  }

  

  /**
  * (Write-Only)  Password for the LDAP account used to access the LDAP server
  * @return authPassword
  **/
  @Schema(description = "(Write-Only)  Password for the LDAP account used to access the LDAP server")
  public String getAuthPassword() {
    return authPassword;
  }
  public void setAuthPassword(String authPassword) {
    this.authPassword = authPassword;
  }
  /**
  * (Read-only) Has the password been set for the LDAP account used to access the LDAP server
  * @return hasAuthPassword
  **/
  @Schema(description = "(Read-only) Has the password been set for the LDAP account used to access the LDAP server")
  public Boolean isHasAuthPassword() {
    return hasAuthPassword;
  }
  public LDAPConfig userBindBaseDn(String userBindBaseDn) {
    this.userBindBaseDn = userBindBaseDn;
    return this;
  }

  

  /**
  * Distinguished name of LDAP node used as the base for user searches
  * @return userBindBaseDn
  **/
  @Schema(description = "Distinguished name of LDAP node used as the base for user searches")
  public String getUserBindBaseDn() {
    return userBindBaseDn;
  }
  public void setUserBindBaseDn(String userBindBaseDn) {
    this.userBindBaseDn = userBindBaseDn;
  }
  public LDAPConfig userIdAttributeNames(String userIdAttributeNames) {
    this.userIdAttributeNames = userIdAttributeNames;
    return this;
  }

  

  /**
  * Name(s) of user record attributes used for matching user login id (comma separated list)
  * @return userIdAttributeNames
  **/
  @Schema(description = "Name(s) of user record attributes used for matching user login id (comma separated list)")
  public String getUserIdAttributeNames() {
    return userIdAttributeNames;
  }
  public void setUserIdAttributeNames(String userIdAttributeNames) {
    this.userIdAttributeNames = userIdAttributeNames;
  }
  public LDAPConfig userObjectclass(String userObjectclass) {
    this.userObjectclass = userObjectclass;
    return this;
  }

  

  /**
  * (Optional) Name of user record objectclass used for finding user during login id
  * @return userObjectclass
  **/
  @Schema(description = "(Optional) Name of user record objectclass used for finding user during login id")
  public String getUserObjectclass() {
    return userObjectclass;
  }
  public void setUserObjectclass(String userObjectclass) {
    this.userObjectclass = userObjectclass;
  }
  public LDAPConfig userCustomFilter(String userCustomFilter) {
    this.userCustomFilter = userCustomFilter;
    return this;
  }

  

  /**
  * (Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via &#x27;and&#x27; with the other generated filter clauses.
  * @return userCustomFilter
  **/
  @Schema(description = "(Optional) Custom RFC-2254 filter clause for use in finding user during login. Combined via 'and' with the other generated filter clauses.")
  public String getUserCustomFilter() {
    return userCustomFilter;
  }
  public void setUserCustomFilter(String userCustomFilter) {
    this.userCustomFilter = userCustomFilter;
  }
  public LDAPConfig userAttributeMapEmail(String userAttributeMapEmail) {
    this.userAttributeMapEmail = userAttributeMapEmail;
    return this;
  }

  

  /**
  * Name of user record attributes used to indicate email address field
  * @return userAttributeMapEmail
  **/
  @Schema(description = "Name of user record attributes used to indicate email address field")
  public String getUserAttributeMapEmail() {
    return userAttributeMapEmail;
  }
  public void setUserAttributeMapEmail(String userAttributeMapEmail) {
    this.userAttributeMapEmail = userAttributeMapEmail;
  }
  public LDAPConfig userAttributeMapFirstName(String userAttributeMapFirstName) {
    this.userAttributeMapFirstName = userAttributeMapFirstName;
    return this;
  }

  

  /**
  * Name of user record attributes used to indicate first name
  * @return userAttributeMapFirstName
  **/
  @Schema(description = "Name of user record attributes used to indicate first name")
  public String getUserAttributeMapFirstName() {
    return userAttributeMapFirstName;
  }
  public void setUserAttributeMapFirstName(String userAttributeMapFirstName) {
    this.userAttributeMapFirstName = userAttributeMapFirstName;
  }
  public LDAPConfig userAttributeMapLastName(String userAttributeMapLastName) {
    this.userAttributeMapLastName = userAttributeMapLastName;
    return this;
  }

  

  /**
  * Name of user record attributes used to indicate last name
  * @return userAttributeMapLastName
  **/
  @Schema(description = "Name of user record attributes used to indicate last name")
  public String getUserAttributeMapLastName() {
    return userAttributeMapLastName;
  }
  public void setUserAttributeMapLastName(String userAttributeMapLastName) {
    this.userAttributeMapLastName = userAttributeMapLastName;
  }
  public LDAPConfig userAttributeMapLdapId(String userAttributeMapLdapId) {
    this.userAttributeMapLdapId = userAttributeMapLdapId;
    return this;
  }

  

  /**
  * Name of user record attributes used to indicate unique record id
  * @return userAttributeMapLdapId
  **/
  @Schema(description = "Name of user record attributes used to indicate unique record id")
  public String getUserAttributeMapLdapId() {
    return userAttributeMapLdapId;
  }
  public void setUserAttributeMapLdapId(String userAttributeMapLdapId) {
    this.userAttributeMapLdapId = userAttributeMapLdapId;
  }
  public LDAPConfig mergeNewUsersByEmail(Boolean mergeNewUsersByEmail) {
    this.mergeNewUsersByEmail = mergeNewUsersByEmail;
    return this;
  }

  

  /**
  * Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.
  * @return mergeNewUsersByEmail
  **/
  @Schema(description = "Merge first-time ldap login to existing user account by email addresses. When a user logs in for the first time via ldap this option will connect this user into their existing account by finding the account with a matching email address. Otherwise a new user account will be created for the user.")
  public Boolean isMergeNewUsersByEmail() {
    return mergeNewUsersByEmail;
  }
  public void setMergeNewUsersByEmail(Boolean mergeNewUsersByEmail) {
    this.mergeNewUsersByEmail = mergeNewUsersByEmail;
  }
  public LDAPConfig alternateEmailLoginAllowed(Boolean alternateEmailLoginAllowed) {
    this.alternateEmailLoginAllowed = alternateEmailLoginAllowed;
    return this;
  }

  

  /**
  * Allow alternate email-based login via &#x27;/login/email&#x27; for admins and for specified users with the &#x27;login_special_email&#x27; permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
  * @return alternateEmailLoginAllowed
  **/
  @Schema(description = "Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.")
  public Boolean isAlternateEmailLoginAllowed() {
    return alternateEmailLoginAllowed;
  }
  public void setAlternateEmailLoginAllowed(Boolean alternateEmailLoginAllowed) {
    this.alternateEmailLoginAllowed = alternateEmailLoginAllowed;
  }
  /**
  * When this config was last modified
  * @return modifiedAt
  **/
  @Schema(description = "When this config was last modified")
  public String getModifiedAt() {
    return modifiedAt;
  }
  /**
  * User id of user who last modified this config
  * @return modifiedBy
  **/
  @Schema(description = "User id of user who last modified this config")
  public String getModifiedBy() {
    return modifiedBy;
  }
  /**
  * (Read-only) Groups that will be applied to new users the first time they login via LDAP
  * @return defaultNewUserGroups
  **/
  @Schema(description = "(Read-only) Groups that will be applied to new users the first time they login via LDAP")
  public List<Group> getDefaultNewUserGroups() {
    return defaultNewUserGroups;
  }
  /**
  * (Read-only) Roles that will be applied to new users the first time they login via LDAP
  * @return defaultNewUserRoles
  **/
  @Schema(description = "(Read-only) Roles that will be applied to new users the first time they login via LDAP")
  public List<Role> getDefaultNewUserRoles() {
    return defaultNewUserRoles;
  }
  public LDAPConfig defaultNewUserRoleIds(List<Long> defaultNewUserRoleIds) {
    this.defaultNewUserRoleIds = defaultNewUserRoleIds;
    return this;
  }

  public LDAPConfig addDefaultNewUserRoleIdsItem(Long defaultNewUserRoleIdsItem) {
    if (this.defaultNewUserRoleIds == null) {
      this.defaultNewUserRoleIds = new ArrayList<Long>();
    }
    this.defaultNewUserRoleIds.add(defaultNewUserRoleIdsItem);
    return this;
  }

  /**
  * (Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP
  * @return defaultNewUserRoleIds
  **/
  @Schema(description = "(Write-Only)  Array of ids of roles that will be applied to new users the first time they login via LDAP")
  public List<Long> getDefaultNewUserRoleIds() {
    return defaultNewUserRoleIds;
  }
  public void setDefaultNewUserRoleIds(List<Long> defaultNewUserRoleIds) {
    this.defaultNewUserRoleIds = defaultNewUserRoleIds;
  }
  public LDAPConfig defaultNewUserGroupIds(List<Long> defaultNewUserGroupIds) {
    this.defaultNewUserGroupIds = defaultNewUserGroupIds;
    return this;
  }

  public LDAPConfig addDefaultNewUserGroupIdsItem(Long defaultNewUserGroupIdsItem) {
    if (this.defaultNewUserGroupIds == null) {
      this.defaultNewUserGroupIds = new ArrayList<Long>();
    }
    this.defaultNewUserGroupIds.add(defaultNewUserGroupIdsItem);
    return this;
  }

  /**
  * (Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP
  * @return defaultNewUserGroupIds
  **/
  @Schema(description = "(Write-Only)  Array of ids of groups that will be applied to new users the first time they login via LDAP")
  public List<Long> getDefaultNewUserGroupIds() {
    return defaultNewUserGroupIds;
  }
  public void setDefaultNewUserGroupIds(List<Long> defaultNewUserGroupIds) {
    this.defaultNewUserGroupIds = defaultNewUserGroupIds;
  }
  public LDAPConfig setRolesFromGroups(Boolean setRolesFromGroups) {
    this.setRolesFromGroups = setRolesFromGroups;
    return this;
  }

  

  /**
  * Set user roles in Looker based on groups from LDAP
  * @return setRolesFromGroups
  **/
  @Schema(description = "Set user roles in Looker based on groups from LDAP")
  public Boolean isSetRolesFromGroups() {
    return setRolesFromGroups;
  }
  public void setSetRolesFromGroups(Boolean setRolesFromGroups) {
    this.setRolesFromGroups = setRolesFromGroups;
  }
  /**
  * (Read-only) Array of mappings between LDAP Groups and Looker Roles
  * @return groups
  **/
  @Schema(description = "(Read-only) Array of mappings between LDAP Groups and Looker Roles")
  public List<LDAPGroupRead> getGroups() {
    return groups;
  }
  public LDAPConfig groupsWithRoleIds(List<LDAPGroupWrite> groupsWithRoleIds) {
    this.groupsWithRoleIds = groupsWithRoleIds;
    return this;
  }

  public LDAPConfig addGroupsWithRoleIdsItem(LDAPGroupWrite groupsWithRoleIdsItem) {
    if (this.groupsWithRoleIds == null) {
      this.groupsWithRoleIds = new ArrayList<LDAPGroupWrite>();
    }
    this.groupsWithRoleIds.add(groupsWithRoleIdsItem);
    return this;
  }

  /**
  * (Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids
  * @return groupsWithRoleIds
  **/
  @Schema(description = "(Read/Write) Array of mappings between LDAP Groups and arrays of Looker Role ids")
  public List<LDAPGroupWrite> getGroupsWithRoleIds() {
    return groupsWithRoleIds;
  }
  public void setGroupsWithRoleIds(List<LDAPGroupWrite> groupsWithRoleIds) {
    this.groupsWithRoleIds = groupsWithRoleIds;
  }
  public LDAPConfig authRequiresRole(Boolean authRequiresRole) {
    this.authRequiresRole = authRequiresRole;
    return this;
  }

  

  /**
  * Users will not be allowed to login at all unless a role for them is found in LDAP if set to true
  * @return authRequiresRole
  **/
  @Schema(description = "Users will not be allowed to login at all unless a role for them is found in LDAP if set to true")
  public Boolean isAuthRequiresRole() {
    return authRequiresRole;
  }
  public void setAuthRequiresRole(Boolean authRequiresRole) {
    this.authRequiresRole = authRequiresRole;
  }
  public LDAPConfig groupsFinderType(String groupsFinderType) {
    this.groupsFinderType = groupsFinderType;
    return this;
  }

  

  /**
  * Identifier for a strategy for how Looker will search for groups in the LDAP server
  * @return groupsFinderType
  **/
  @Schema(description = "Identifier for a strategy for how Looker will search for groups in the LDAP server")
  public String getGroupsFinderType() {
    return groupsFinderType;
  }
  public void setGroupsFinderType(String groupsFinderType) {
    this.groupsFinderType = groupsFinderType;
  }
  public LDAPConfig groupsBaseDn(String groupsBaseDn) {
    this.groupsBaseDn = groupsBaseDn;
    return this;
  }

  

  /**
  * Base dn for finding groups in LDAP searches
  * @return groupsBaseDn
  **/
  @Schema(description = "Base dn for finding groups in LDAP searches")
  public String getGroupsBaseDn() {
    return groupsBaseDn;
  }
  public void setGroupsBaseDn(String groupsBaseDn) {
    this.groupsBaseDn = groupsBaseDn;
  }
  public LDAPConfig groupsMemberAttribute(String groupsMemberAttribute) {
    this.groupsMemberAttribute = groupsMemberAttribute;
    return this;
  }

  

  /**
  * LDAP Group attribute that signifies the members of the groups. Most commonly &#x27;member&#x27;
  * @return groupsMemberAttribute
  **/
  @Schema(description = "LDAP Group attribute that signifies the members of the groups. Most commonly 'member'")
  public String getGroupsMemberAttribute() {
    return groupsMemberAttribute;
  }
  public void setGroupsMemberAttribute(String groupsMemberAttribute) {
    this.groupsMemberAttribute = groupsMemberAttribute;
  }
  public LDAPConfig groupsUserAttribute(String groupsUserAttribute) {
    this.groupsUserAttribute = groupsUserAttribute;
    return this;
  }

  

  /**
  * LDAP Group attribute that signifies the user in a group. Most commonly &#x27;dn&#x27;
  * @return groupsUserAttribute
  **/
  @Schema(description = "LDAP Group attribute that signifies the user in a group. Most commonly 'dn'")
  public String getGroupsUserAttribute() {
    return groupsUserAttribute;
  }
  public void setGroupsUserAttribute(String groupsUserAttribute) {
    this.groupsUserAttribute = groupsUserAttribute;
  }
  public LDAPConfig groupsObjectclasses(String groupsObjectclasses) {
    this.groupsObjectclasses = groupsObjectclasses;
    return this;
  }

  

  /**
  * Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches
  * @return groupsObjectclasses
  **/
  @Schema(description = "Optional comma-separated list of supported LDAP objectclass for groups when doing groups searches")
  public String getGroupsObjectclasses() {
    return groupsObjectclasses;
  }
  public void setGroupsObjectclasses(String groupsObjectclasses) {
    this.groupsObjectclasses = groupsObjectclasses;
  }
  public LDAPConfig forceNoPage(Boolean forceNoPage) {
    this.forceNoPage = forceNoPage;
    return this;
  }

  

  /**
  * Don&#x27;t attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.
  * @return forceNoPage
  **/
  @Schema(description = "Don't attempt to do LDAP search result paging (RFC 2696) even if the LDAP server claims to support it.")
  public Boolean isForceNoPage() {
    return forceNoPage;
  }
  public void setForceNoPage(Boolean forceNoPage) {
    this.forceNoPage = forceNoPage;
  }
  public LDAPConfig testLdapUser(String testLdapUser) {
    this.testLdapUser = testLdapUser;
    return this;
  }

  

  /**
  * (Write-Only)  Test LDAP user login id. For ldap tests only.
  * @return testLdapUser
  **/
  @Schema(description = "(Write-Only)  Test LDAP user login id. For ldap tests only.")
  public String getTestLdapUser() {
    return testLdapUser;
  }
  public void setTestLdapUser(String testLdapUser) {
    this.testLdapUser = testLdapUser;
  }
  public LDAPConfig testLdapPassword(String testLdapPassword) {
    this.testLdapPassword = testLdapPassword;
    return this;
  }

  

  /**
  * (Write-Only)  Test LDAP user password. For ldap tests only.
  * @return testLdapPassword
  **/
  @Schema(description = "(Write-Only)  Test LDAP user password. For ldap tests only.")
  public String getTestLdapPassword() {
    return testLdapPassword;
  }
  public void setTestLdapPassword(String testLdapPassword) {
    this.testLdapPassword = testLdapPassword;
  }
  /**
  * (Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes
  * @return userAttributes
  **/
  @Schema(description = "(Read-only) Array of mappings between LDAP User Attributes and Looker User Attributes")
  public List<LDAPUserAttributeRead> getUserAttributes() {
    return userAttributes;
  }
  public LDAPConfig userAttributesWithIds(List<LDAPUserAttributeWrite> userAttributesWithIds) {
    this.userAttributesWithIds = userAttributesWithIds;
    return this;
  }

  public LDAPConfig addUserAttributesWithIdsItem(LDAPUserAttributeWrite userAttributesWithIdsItem) {
    if (this.userAttributesWithIds == null) {
      this.userAttributesWithIds = new ArrayList<LDAPUserAttributeWrite>();
    }
    this.userAttributesWithIds.add(userAttributesWithIdsItem);
    return this;
  }

  /**
  * (Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids
  * @return userAttributesWithIds
  **/
  @Schema(description = "(Read/Write) Array of mappings between LDAP User Attributes and arrays of Looker User Attribute ids")
  public List<LDAPUserAttributeWrite> getUserAttributesWithIds() {
    return userAttributesWithIds;
  }
  public void setUserAttributesWithIds(List<LDAPUserAttributeWrite> userAttributesWithIds) {
    this.userAttributesWithIds = userAttributesWithIds;
  }
  /**
  * Link to get this item
  * @return url
  **/
  @Schema(description = "Link to get this item")
  public String getUrl() {
    return url;
  }
  /**
  * Operations the current user is able to perform on this object
  * @return can
  **/
  @Schema(description = "Operations the current user is able to perform on this object")
  public Map<String, Boolean> getCan() {
    return can;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LDAPConfig ldAPConfig = (LDAPConfig) o;
    return Objects.equals(this.enabled, ldAPConfig.enabled) &&
        Objects.equals(this.connectionHost, ldAPConfig.connectionHost) &&
        Objects.equals(this.connectionPort, ldAPConfig.connectionPort) &&
        Objects.equals(this.connectionTls, ldAPConfig.connectionTls) &&
        Objects.equals(this.connectionTlsNoVerify, ldAPConfig.connectionTlsNoVerify) &&
        Objects.equals(this.authUsername, ldAPConfig.authUsername) &&
        Objects.equals(this.authPassword, ldAPConfig.authPassword) &&
        Objects.equals(this.hasAuthPassword, ldAPConfig.hasAuthPassword) &&
        Objects.equals(this.userBindBaseDn, ldAPConfig.userBindBaseDn) &&
        Objects.equals(this.userIdAttributeNames, ldAPConfig.userIdAttributeNames) &&
        Objects.equals(this.userObjectclass, ldAPConfig.userObjectclass) &&
        Objects.equals(this.userCustomFilter, ldAPConfig.userCustomFilter) &&
        Objects.equals(this.userAttributeMapEmail, ldAPConfig.userAttributeMapEmail) &&
        Objects.equals(this.userAttributeMapFirstName, ldAPConfig.userAttributeMapFirstName) &&
        Objects.equals(this.userAttributeMapLastName, ldAPConfig.userAttributeMapLastName) &&
        Objects.equals(this.userAttributeMapLdapId, ldAPConfig.userAttributeMapLdapId) &&
        Objects.equals(this.mergeNewUsersByEmail, ldAPConfig.mergeNewUsersByEmail) &&
        Objects.equals(this.alternateEmailLoginAllowed, ldAPConfig.alternateEmailLoginAllowed) &&
        Objects.equals(this.modifiedAt, ldAPConfig.modifiedAt) &&
        Objects.equals(this.modifiedBy, ldAPConfig.modifiedBy) &&
        Objects.equals(this.defaultNewUserGroups, ldAPConfig.defaultNewUserGroups) &&
        Objects.equals(this.defaultNewUserRoles, ldAPConfig.defaultNewUserRoles) &&
        Objects.equals(this.defaultNewUserRoleIds, ldAPConfig.defaultNewUserRoleIds) &&
        Objects.equals(this.defaultNewUserGroupIds, ldAPConfig.defaultNewUserGroupIds) &&
        Objects.equals(this.setRolesFromGroups, ldAPConfig.setRolesFromGroups) &&
        Objects.equals(this.groups, ldAPConfig.groups) &&
        Objects.equals(this.groupsWithRoleIds, ldAPConfig.groupsWithRoleIds) &&
        Objects.equals(this.authRequiresRole, ldAPConfig.authRequiresRole) &&
        Objects.equals(this.groupsFinderType, ldAPConfig.groupsFinderType) &&
        Objects.equals(this.groupsBaseDn, ldAPConfig.groupsBaseDn) &&
        Objects.equals(this.groupsMemberAttribute, ldAPConfig.groupsMemberAttribute) &&
        Objects.equals(this.groupsUserAttribute, ldAPConfig.groupsUserAttribute) &&
        Objects.equals(this.groupsObjectclasses, ldAPConfig.groupsObjectclasses) &&
        Objects.equals(this.forceNoPage, ldAPConfig.forceNoPage) &&
        Objects.equals(this.testLdapUser, ldAPConfig.testLdapUser) &&
        Objects.equals(this.testLdapPassword, ldAPConfig.testLdapPassword) &&
        Objects.equals(this.userAttributes, ldAPConfig.userAttributes) &&
        Objects.equals(this.userAttributesWithIds, ldAPConfig.userAttributesWithIds) &&
        Objects.equals(this.url, ldAPConfig.url) &&
        Objects.equals(this.can, ldAPConfig.can);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(enabled, connectionHost, connectionPort, connectionTls, connectionTlsNoVerify, authUsername, authPassword, hasAuthPassword, userBindBaseDn, userIdAttributeNames, userObjectclass, userCustomFilter, userAttributeMapEmail, userAttributeMapFirstName, userAttributeMapLastName, userAttributeMapLdapId, mergeNewUsersByEmail, alternateEmailLoginAllowed, modifiedAt, modifiedBy, defaultNewUserGroups, defaultNewUserRoles, defaultNewUserRoleIds, defaultNewUserGroupIds, setRolesFromGroups, groups, groupsWithRoleIds, authRequiresRole, groupsFinderType, groupsBaseDn, groupsMemberAttribute, groupsUserAttribute, groupsObjectclasses, forceNoPage, testLdapUser, testLdapPassword, userAttributes, userAttributesWithIds, url, can);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LDAPConfig {\n");
    
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    connectionHost: ").append(toIndentedString(connectionHost)).append("\n");
    sb.append("    connectionPort: ").append(toIndentedString(connectionPort)).append("\n");
    sb.append("    connectionTls: ").append(toIndentedString(connectionTls)).append("\n");
    sb.append("    connectionTlsNoVerify: ").append(toIndentedString(connectionTlsNoVerify)).append("\n");
    sb.append("    authUsername: ").append(toIndentedString(authUsername)).append("\n");
    sb.append("    authPassword: ").append(toIndentedString(authPassword)).append("\n");
    sb.append("    hasAuthPassword: ").append(toIndentedString(hasAuthPassword)).append("\n");
    sb.append("    userBindBaseDn: ").append(toIndentedString(userBindBaseDn)).append("\n");
    sb.append("    userIdAttributeNames: ").append(toIndentedString(userIdAttributeNames)).append("\n");
    sb.append("    userObjectclass: ").append(toIndentedString(userObjectclass)).append("\n");
    sb.append("    userCustomFilter: ").append(toIndentedString(userCustomFilter)).append("\n");
    sb.append("    userAttributeMapEmail: ").append(toIndentedString(userAttributeMapEmail)).append("\n");
    sb.append("    userAttributeMapFirstName: ").append(toIndentedString(userAttributeMapFirstName)).append("\n");
    sb.append("    userAttributeMapLastName: ").append(toIndentedString(userAttributeMapLastName)).append("\n");
    sb.append("    userAttributeMapLdapId: ").append(toIndentedString(userAttributeMapLdapId)).append("\n");
    sb.append("    mergeNewUsersByEmail: ").append(toIndentedString(mergeNewUsersByEmail)).append("\n");
    sb.append("    alternateEmailLoginAllowed: ").append(toIndentedString(alternateEmailLoginAllowed)).append("\n");
    sb.append("    modifiedAt: ").append(toIndentedString(modifiedAt)).append("\n");
    sb.append("    modifiedBy: ").append(toIndentedString(modifiedBy)).append("\n");
    sb.append("    defaultNewUserGroups: ").append(toIndentedString(defaultNewUserGroups)).append("\n");
    sb.append("    defaultNewUserRoles: ").append(toIndentedString(defaultNewUserRoles)).append("\n");
    sb.append("    defaultNewUserRoleIds: ").append(toIndentedString(defaultNewUserRoleIds)).append("\n");
    sb.append("    defaultNewUserGroupIds: ").append(toIndentedString(defaultNewUserGroupIds)).append("\n");
    sb.append("    setRolesFromGroups: ").append(toIndentedString(setRolesFromGroups)).append("\n");
    sb.append("    groups: ").append(toIndentedString(groups)).append("\n");
    sb.append("    groupsWithRoleIds: ").append(toIndentedString(groupsWithRoleIds)).append("\n");
    sb.append("    authRequiresRole: ").append(toIndentedString(authRequiresRole)).append("\n");
    sb.append("    groupsFinderType: ").append(toIndentedString(groupsFinderType)).append("\n");
    sb.append("    groupsBaseDn: ").append(toIndentedString(groupsBaseDn)).append("\n");
    sb.append("    groupsMemberAttribute: ").append(toIndentedString(groupsMemberAttribute)).append("\n");
    sb.append("    groupsUserAttribute: ").append(toIndentedString(groupsUserAttribute)).append("\n");
    sb.append("    groupsObjectclasses: ").append(toIndentedString(groupsObjectclasses)).append("\n");
    sb.append("    forceNoPage: ").append(toIndentedString(forceNoPage)).append("\n");
    sb.append("    testLdapUser: ").append(toIndentedString(testLdapUser)).append("\n");
    sb.append("    testLdapPassword: ").append(toIndentedString(testLdapPassword)).append("\n");
    sb.append("    userAttributes: ").append(toIndentedString(userAttributes)).append("\n");
    sb.append("    userAttributesWithIds: ").append(toIndentedString(userAttributesWithIds)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    can: ").append(toIndentedString(can)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
