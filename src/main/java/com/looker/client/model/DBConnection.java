/*
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@looker.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.looker.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.looker.client.model.DBConnectionOverride;
import com.looker.client.model.Dialect;
import com.looker.client.model.Snippet;

import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * DBConnection
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-02-15T12:39:13.185-08:00[America/Los_Angeles]")public class DBConnection {

  @SerializedName("name")
  private String name = null;

  @SerializedName("dialect")
  private Dialect dialect = null;

  @SerializedName("snippets")
  private List<Snippet> snippets = null;

  @SerializedName("host")
  private String host = null;

  @SerializedName("port")
  private String port = null;

  @SerializedName("username")
  private String username = null;

  @SerializedName("password")
  private String password = null;

  @SerializedName("certificate")
  private String certificate = null;

  @SerializedName("file_type")
  private String fileType = null;

  @SerializedName("database")
  private String database = null;

  @SerializedName("db_timezone")
  private String dbTimezone = null;

  @SerializedName("query_timezone")
  private String queryTimezone = null;

  @SerializedName("schema")
  private String schema = null;

  @SerializedName("max_connections")
  private Long maxConnections = null;

  @SerializedName("max_billing_gigabytes")
  private String maxBillingGigabytes = null;

  @SerializedName("ssl")
  private Boolean ssl = null;

  @SerializedName("verify_ssl")
  private Boolean verifySsl = null;

  @SerializedName("tmp_db_name")
  private String tmpDbName = null;

  @SerializedName("jdbc_additional_params")
  private String jdbcAdditionalParams = null;

  @SerializedName("pool_timeout")
  private Long poolTimeout = null;

  @SerializedName("dialect_name")
  private String dialectName = null;

  @SerializedName("created_at")
  private String createdAt = null;

  @SerializedName("user_id")
  private String userId = null;

  @SerializedName("example")
  private Boolean example = null;

  @SerializedName("user_db_credentials")
  private Boolean userDbCredentials = null;

  @SerializedName("user_attribute_fields")
  private List<String> userAttributeFields = null;

  @SerializedName("maintenance_cron")
  private String maintenanceCron = null;

  @SerializedName("last_regen_at")
  private String lastRegenAt = null;

  @SerializedName("last_reap_at")
  private String lastReapAt = null;

  @SerializedName("sql_runner_precache_tables")
  private Boolean sqlRunnerPrecacheTables = null;

  @SerializedName("after_connect_statements")
  private String afterConnectStatements = null;

  @SerializedName("pdt_context_override")
  private DBConnectionOverride pdtContextOverride = null;

  @SerializedName("can")
  private Map<String, Boolean> can = null;
  public DBConnection name(String name) {
    this.name = name;
    return this;
  }

  

  /**
  * Name of the connection. Also used as the unique identifier
  * @return name
  **/
  @Schema(description = "Name of the connection. Also used as the unique identifier")
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public DBConnection dialect(Dialect dialect) {
    this.dialect = dialect;
    return this;
  }

  

  /**
  * Get dialect
  * @return dialect
  **/
  @Schema(description = "")
  public Dialect getDialect() {
    return dialect;
  }
  public void setDialect(Dialect dialect) {
    this.dialect = dialect;
  }
  /**
  * SQL Runner snippets for this connection
  * @return snippets
  **/
  @Schema(description = "SQL Runner snippets for this connection")
  public List<Snippet> getSnippets() {
    return snippets;
  }
  public DBConnection host(String host) {
    this.host = host;
    return this;
  }

  

  /**
  * Host name/address of server
  * @return host
  **/
  @Schema(description = "Host name/address of server")
  public String getHost() {
    return host;
  }
  public void setHost(String host) {
    this.host = host;
  }
  public DBConnection port(String port) {
    this.port = port;
    return this;
  }

  

  /**
  * Port number on server
  * @return port
  **/
  @Schema(description = "Port number on server")
  public String getPort() {
    return port;
  }
  public void setPort(String port) {
    this.port = port;
  }
  public DBConnection username(String username) {
    this.username = username;
    return this;
  }

  

  /**
  * Username for server authentication
  * @return username
  **/
  @Schema(description = "Username for server authentication")
  public String getUsername() {
    return username;
  }
  public void setUsername(String username) {
    this.username = username;
  }
  public DBConnection password(String password) {
    this.password = password;
    return this;
  }

  

  /**
  * (Write-Only) Password for server authentication
  * @return password
  **/
  @Schema(description = "(Write-Only) Password for server authentication")
  public String getPassword() {
    return password;
  }
  public void setPassword(String password) {
    this.password = password;
  }
  public DBConnection certificate(String certificate) {
    this.certificate = certificate;
    return this;
  }

  

  /**
  * (Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).
  * @return certificate
  **/
  @Schema(description = "(Write-Only) Base64 encoded Certificate body for server authentication (when appropriate for dialect).")
  public String getCertificate() {
    return certificate;
  }
  public void setCertificate(String certificate) {
    this.certificate = certificate;
  }
  public DBConnection fileType(String fileType) {
    this.fileType = fileType;
    return this;
  }

  

  /**
  * (Write-Only) Certificate keyfile type - .json or .p12
  * @return fileType
  **/
  @Schema(description = "(Write-Only) Certificate keyfile type - .json or .p12")
  public String getFileType() {
    return fileType;
  }
  public void setFileType(String fileType) {
    this.fileType = fileType;
  }
  public DBConnection database(String database) {
    this.database = database;
    return this;
  }

  

  /**
  * Database name
  * @return database
  **/
  @Schema(description = "Database name")
  public String getDatabase() {
    return database;
  }
  public void setDatabase(String database) {
    this.database = database;
  }
  public DBConnection dbTimezone(String dbTimezone) {
    this.dbTimezone = dbTimezone;
    return this;
  }

  

  /**
  * Time zone of database
  * @return dbTimezone
  **/
  @Schema(description = "Time zone of database")
  public String getDbTimezone() {
    return dbTimezone;
  }
  public void setDbTimezone(String dbTimezone) {
    this.dbTimezone = dbTimezone;
  }
  public DBConnection queryTimezone(String queryTimezone) {
    this.queryTimezone = queryTimezone;
    return this;
  }

  

  /**
  * Timezone to use in queries
  * @return queryTimezone
  **/
  @Schema(description = "Timezone to use in queries")
  public String getQueryTimezone() {
    return queryTimezone;
  }
  public void setQueryTimezone(String queryTimezone) {
    this.queryTimezone = queryTimezone;
  }
  public DBConnection schema(String schema) {
    this.schema = schema;
    return this;
  }

  

  /**
  * Scheme name
  * @return schema
  **/
  @Schema(description = "Scheme name")
  public String getSchema() {
    return schema;
  }
  public void setSchema(String schema) {
    this.schema = schema;
  }
  public DBConnection maxConnections(Long maxConnections) {
    this.maxConnections = maxConnections;
    return this;
  }

  

  /**
  * Maximum number of concurrent connection to use
  * @return maxConnections
  **/
  @Schema(description = "Maximum number of concurrent connection to use")
  public Long getMaxConnections() {
    return maxConnections;
  }
  public void setMaxConnections(Long maxConnections) {
    this.maxConnections = maxConnections;
  }
  public DBConnection maxBillingGigabytes(String maxBillingGigabytes) {
    this.maxBillingGigabytes = maxBillingGigabytes;
    return this;
  }

  

  /**
  * Maximum size of query in GBs (BigQuery only, can be a user_attribute name)
  * @return maxBillingGigabytes
  **/
  @Schema(description = "Maximum size of query in GBs (BigQuery only, can be a user_attribute name)")
  public String getMaxBillingGigabytes() {
    return maxBillingGigabytes;
  }
  public void setMaxBillingGigabytes(String maxBillingGigabytes) {
    this.maxBillingGigabytes = maxBillingGigabytes;
  }
  public DBConnection ssl(Boolean ssl) {
    this.ssl = ssl;
    return this;
  }

  

  /**
  * Use SSL/TLS when connecting to server
  * @return ssl
  **/
  @Schema(description = "Use SSL/TLS when connecting to server")
  public Boolean isSsl() {
    return ssl;
  }
  public void setSsl(Boolean ssl) {
    this.ssl = ssl;
  }
  public DBConnection verifySsl(Boolean verifySsl) {
    this.verifySsl = verifySsl;
    return this;
  }

  

  /**
  * Verify the SSL
  * @return verifySsl
  **/
  @Schema(description = "Verify the SSL")
  public Boolean isVerifySsl() {
    return verifySsl;
  }
  public void setVerifySsl(Boolean verifySsl) {
    this.verifySsl = verifySsl;
  }
  public DBConnection tmpDbName(String tmpDbName) {
    this.tmpDbName = tmpDbName;
    return this;
  }

  

  /**
  * Name of temporary database (if used)
  * @return tmpDbName
  **/
  @Schema(description = "Name of temporary database (if used)")
  public String getTmpDbName() {
    return tmpDbName;
  }
  public void setTmpDbName(String tmpDbName) {
    this.tmpDbName = tmpDbName;
  }
  public DBConnection jdbcAdditionalParams(String jdbcAdditionalParams) {
    this.jdbcAdditionalParams = jdbcAdditionalParams;
    return this;
  }

  

  /**
  * Additional params to add to JDBC connection string
  * @return jdbcAdditionalParams
  **/
  @Schema(description = "Additional params to add to JDBC connection string")
  public String getJdbcAdditionalParams() {
    return jdbcAdditionalParams;
  }
  public void setJdbcAdditionalParams(String jdbcAdditionalParams) {
    this.jdbcAdditionalParams = jdbcAdditionalParams;
  }
  public DBConnection poolTimeout(Long poolTimeout) {
    this.poolTimeout = poolTimeout;
    return this;
  }

  

  /**
  * Pool Timeout
  * @return poolTimeout
  **/
  @Schema(description = "Pool Timeout")
  public Long getPoolTimeout() {
    return poolTimeout;
  }
  public void setPoolTimeout(Long poolTimeout) {
    this.poolTimeout = poolTimeout;
  }
  public DBConnection dialectName(String dialectName) {
    this.dialectName = dialectName;
    return this;
  }

  

  /**
  * (Read/Write) SQL Dialect name
  * @return dialectName
  **/
  @Schema(description = "(Read/Write) SQL Dialect name")
  public String getDialectName() {
    return dialectName;
  }
  public void setDialectName(String dialectName) {
    this.dialectName = dialectName;
  }
  /**
  * Creation date for this connection
  * @return createdAt
  **/
  @Schema(description = "Creation date for this connection")
  public String getCreatedAt() {
    return createdAt;
  }
  /**
  * Id of user who last modified this connection configuration
  * @return userId
  **/
  @Schema(description = "Id of user who last modified this connection configuration")
  public String getUserId() {
    return userId;
  }
  /**
  * Is this an example connection
  * @return example
  **/
  @Schema(description = "Is this an example connection")
  public Boolean isExample() {
    return example;
  }
  public DBConnection userDbCredentials(Boolean userDbCredentials) {
    this.userDbCredentials = userDbCredentials;
    return this;
  }

  

  /**
  * (Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password
  * @return userDbCredentials
  **/
  @Schema(description = "(Limited access feature) Are per user db credentials enabled. Enabling will remove previously set username and password")
  public Boolean isUserDbCredentials() {
    return userDbCredentials;
  }
  public void setUserDbCredentials(Boolean userDbCredentials) {
    this.userDbCredentials = userDbCredentials;
  }
  public DBConnection userAttributeFields(List<String> userAttributeFields) {
    this.userAttributeFields = userAttributeFields;
    return this;
  }

  public DBConnection addUserAttributeFieldsItem(String userAttributeFieldsItem) {
    if (this.userAttributeFields == null) {
      this.userAttributeFields = new ArrayList<String>();
    }
    this.userAttributeFields.add(userAttributeFieldsItem);
    return this;
  }

  /**
  * Fields whose values map to user attribute names
  * @return userAttributeFields
  **/
  @Schema(description = "Fields whose values map to user attribute names")
  public List<String> getUserAttributeFields() {
    return userAttributeFields;
  }
  public void setUserAttributeFields(List<String> userAttributeFields) {
    this.userAttributeFields = userAttributeFields;
  }
  public DBConnection maintenanceCron(String maintenanceCron) {
    this.maintenanceCron = maintenanceCron;
    return this;
  }

  

  /**
  * Cron string specifying when maintenance such as PDT trigger checks and drops should be performed
  * @return maintenanceCron
  **/
  @Schema(description = "Cron string specifying when maintenance such as PDT trigger checks and drops should be performed")
  public String getMaintenanceCron() {
    return maintenanceCron;
  }
  public void setMaintenanceCron(String maintenanceCron) {
    this.maintenanceCron = maintenanceCron;
  }
  /**
  * Unix timestamp at start of last completed PDT trigger check process
  * @return lastRegenAt
  **/
  @Schema(description = "Unix timestamp at start of last completed PDT trigger check process")
  public String getLastRegenAt() {
    return lastRegenAt;
  }
  /**
  * Unix timestamp at start of last completed PDT reap process
  * @return lastReapAt
  **/
  @Schema(description = "Unix timestamp at start of last completed PDT reap process")
  public String getLastReapAt() {
    return lastReapAt;
  }
  public DBConnection sqlRunnerPrecacheTables(Boolean sqlRunnerPrecacheTables) {
    this.sqlRunnerPrecacheTables = sqlRunnerPrecacheTables;
    return this;
  }

  

  /**
  * Precache tables in the SQL Runner
  * @return sqlRunnerPrecacheTables
  **/
  @Schema(description = "Precache tables in the SQL Runner")
  public Boolean isSqlRunnerPrecacheTables() {
    return sqlRunnerPrecacheTables;
  }
  public void setSqlRunnerPrecacheTables(Boolean sqlRunnerPrecacheTables) {
    this.sqlRunnerPrecacheTables = sqlRunnerPrecacheTables;
  }
  public DBConnection afterConnectStatements(String afterConnectStatements) {
    this.afterConnectStatements = afterConnectStatements;
    return this;
  }

  

  /**
  * SQL statements (semicolon separated) to issue after connecting to the database. Requires &#x60;custom_after_connect_statements&#x60; license feature
  * @return afterConnectStatements
  **/
  @Schema(description = "SQL statements (semicolon separated) to issue after connecting to the database. Requires `custom_after_connect_statements` license feature")
  public String getAfterConnectStatements() {
    return afterConnectStatements;
  }
  public void setAfterConnectStatements(String afterConnectStatements) {
    this.afterConnectStatements = afterConnectStatements;
  }
  public DBConnection pdtContextOverride(DBConnectionOverride pdtContextOverride) {
    this.pdtContextOverride = pdtContextOverride;
    return this;
  }

  

  /**
  * Get pdtContextOverride
  * @return pdtContextOverride
  **/
  @Schema(description = "")
  public DBConnectionOverride getPdtContextOverride() {
    return pdtContextOverride;
  }
  public void setPdtContextOverride(DBConnectionOverride pdtContextOverride) {
    this.pdtContextOverride = pdtContextOverride;
  }
  /**
  * Operations the current user is able to perform on this object
  * @return can
  **/
  @Schema(description = "Operations the current user is able to perform on this object")
  public Map<String, Boolean> getCan() {
    return can;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DBConnection dbConnection = (DBConnection) o;
    return Objects.equals(this.name, dbConnection.name) &&
        Objects.equals(this.dialect, dbConnection.dialect) &&
        Objects.equals(this.snippets, dbConnection.snippets) &&
        Objects.equals(this.host, dbConnection.host) &&
        Objects.equals(this.port, dbConnection.port) &&
        Objects.equals(this.username, dbConnection.username) &&
        Objects.equals(this.password, dbConnection.password) &&
        Objects.equals(this.certificate, dbConnection.certificate) &&
        Objects.equals(this.fileType, dbConnection.fileType) &&
        Objects.equals(this.database, dbConnection.database) &&
        Objects.equals(this.dbTimezone, dbConnection.dbTimezone) &&
        Objects.equals(this.queryTimezone, dbConnection.queryTimezone) &&
        Objects.equals(this.schema, dbConnection.schema) &&
        Objects.equals(this.maxConnections, dbConnection.maxConnections) &&
        Objects.equals(this.maxBillingGigabytes, dbConnection.maxBillingGigabytes) &&
        Objects.equals(this.ssl, dbConnection.ssl) &&
        Objects.equals(this.verifySsl, dbConnection.verifySsl) &&
        Objects.equals(this.tmpDbName, dbConnection.tmpDbName) &&
        Objects.equals(this.jdbcAdditionalParams, dbConnection.jdbcAdditionalParams) &&
        Objects.equals(this.poolTimeout, dbConnection.poolTimeout) &&
        Objects.equals(this.dialectName, dbConnection.dialectName) &&
        Objects.equals(this.createdAt, dbConnection.createdAt) &&
        Objects.equals(this.userId, dbConnection.userId) &&
        Objects.equals(this.example, dbConnection.example) &&
        Objects.equals(this.userDbCredentials, dbConnection.userDbCredentials) &&
        Objects.equals(this.userAttributeFields, dbConnection.userAttributeFields) &&
        Objects.equals(this.maintenanceCron, dbConnection.maintenanceCron) &&
        Objects.equals(this.lastRegenAt, dbConnection.lastRegenAt) &&
        Objects.equals(this.lastReapAt, dbConnection.lastReapAt) &&
        Objects.equals(this.sqlRunnerPrecacheTables, dbConnection.sqlRunnerPrecacheTables) &&
        Objects.equals(this.afterConnectStatements, dbConnection.afterConnectStatements) &&
        Objects.equals(this.pdtContextOverride, dbConnection.pdtContextOverride) &&
        Objects.equals(this.can, dbConnection.can);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(name, dialect, snippets, host, port, username, password, certificate, fileType, database, dbTimezone, queryTimezone, schema, maxConnections, maxBillingGigabytes, ssl, verifySsl, tmpDbName, jdbcAdditionalParams, poolTimeout, dialectName, createdAt, userId, example, userDbCredentials, userAttributeFields, maintenanceCron, lastRegenAt, lastReapAt, sqlRunnerPrecacheTables, afterConnectStatements, pdtContextOverride, can);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DBConnection {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    dialect: ").append(toIndentedString(dialect)).append("\n");
    sb.append("    snippets: ").append(toIndentedString(snippets)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    certificate: ").append(toIndentedString(certificate)).append("\n");
    sb.append("    fileType: ").append(toIndentedString(fileType)).append("\n");
    sb.append("    database: ").append(toIndentedString(database)).append("\n");
    sb.append("    dbTimezone: ").append(toIndentedString(dbTimezone)).append("\n");
    sb.append("    queryTimezone: ").append(toIndentedString(queryTimezone)).append("\n");
    sb.append("    schema: ").append(toIndentedString(schema)).append("\n");
    sb.append("    maxConnections: ").append(toIndentedString(maxConnections)).append("\n");
    sb.append("    maxBillingGigabytes: ").append(toIndentedString(maxBillingGigabytes)).append("\n");
    sb.append("    ssl: ").append(toIndentedString(ssl)).append("\n");
    sb.append("    verifySsl: ").append(toIndentedString(verifySsl)).append("\n");
    sb.append("    tmpDbName: ").append(toIndentedString(tmpDbName)).append("\n");
    sb.append("    jdbcAdditionalParams: ").append(toIndentedString(jdbcAdditionalParams)).append("\n");
    sb.append("    poolTimeout: ").append(toIndentedString(poolTimeout)).append("\n");
    sb.append("    dialectName: ").append(toIndentedString(dialectName)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    userId: ").append(toIndentedString(userId)).append("\n");
    sb.append("    example: ").append(toIndentedString(example)).append("\n");
    sb.append("    userDbCredentials: ").append(toIndentedString(userDbCredentials)).append("\n");
    sb.append("    userAttributeFields: ").append(toIndentedString(userAttributeFields)).append("\n");
    sb.append("    maintenanceCron: ").append(toIndentedString(maintenanceCron)).append("\n");
    sb.append("    lastRegenAt: ").append(toIndentedString(lastRegenAt)).append("\n");
    sb.append("    lastReapAt: ").append(toIndentedString(lastReapAt)).append("\n");
    sb.append("    sqlRunnerPrecacheTables: ").append(toIndentedString(sqlRunnerPrecacheTables)).append("\n");
    sb.append("    afterConnectStatements: ").append(toIndentedString(afterConnectStatements)).append("\n");
    sb.append("    pdtContextOverride: ").append(toIndentedString(pdtContextOverride)).append("\n");
    sb.append("    can: ").append(toIndentedString(can)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
